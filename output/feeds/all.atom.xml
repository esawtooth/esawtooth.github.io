<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>rohitja.in</title><link href="http://rohitja.in/" rel="alternate"></link><link href="http://rohitja.in/feeds/all.atom.xml" rel="self"></link><id>http://rohitja.in/</id><updated>2015-12-01T11:44:00+05:30</updated><entry><title>A Blog Makeover</title><link href="http://rohitja.in/blog-v2.html" rel="alternate"></link><published>2015-12-01T11:44:00+05:30</published><author><name>Rohit Jain</name></author><id>tag:rohitja.in,2015-12-01:blog-v2.html</id><summary type="html">&lt;p&gt;This one is just a quick update on my latest blog makeover. So this
business started when I discovered that a domain name that I've been
looking for a while just popped back up on the grid. They have a
tendency to do that, so it pays to keep looking once in a while. As an
aside, this has given me an idea for a sort of notification service for
when domains you care (or might care for) for become available. I think
I'll try to spare a weekend for this.&lt;/p&gt;
&lt;p&gt;Anyways, once I bought this domain, I simply had to move my blog
over. Also, I wanted an email address linked to it as well. And of
course, my vpn server and other machines in the cloud had to be moved
onto subdomains of this one as well. Sigh. Given how I had previously
been using octopress for the blog, and that it had lately become
deprecated, I thought I might as well move over to Github Pages and
Jekyll while I was at it. Fortunately, the entire thing above proved to
be less of a pain than it usually is.&lt;/p&gt;
&lt;p&gt;Trawling through the Github documentation got me to a simple jekyll
template site that I was able to link to my custom domain. For now I
have kept the apex domain pointed the blog since I've been too lazy to
maintain some seperate placeholder website. Hopefully I won't have to
either anytime soon. The good thing about the Jekyll move was that I was
simply able to copy over the old markdown files from the source/_posts
directory to the _posts directory of the jekyll tree. The only thing
that required some work was that the default markdown parser used by
jekyll used a different way of quoting code. I've added the facebook
comment plugin as well. May rethink that further down the line, but for
now, I don't see any issues with it other than the login constraint.&lt;/p&gt;
&lt;p&gt;The email was a simple matter of creating a new Zoho Mail account and
aliasing that to my current Gmail account. So now, all mail from my
current Gmail account would be routed through the new email, and all
mail received at the new account would lie waiting for me in the Gmail
account. Piece of cake. One discovery was that I couldn't find the
account settings in Google's Inbox app. Had to do all the work from the
old Gmail interface with the clunky popups. Hopefully they will fix that
soon. Particularly if they ever decide to shutdown the old interface as
they are in the habit of usually doing.&lt;/p&gt;
&lt;p&gt;Phew. Things simply feel neater now. Let's see if this inspires me to
post more often.&lt;/p&gt;</summary><category term="blog tech"></category></entry><entry><title>Hoare Partitioning and Pivot Selection</title><link href="http://rohitja.in/hoare-pivot.html" rel="alternate"></link><published>2015-09-06T16:44:00+05:30</published><author><name>Rohit Jain</name></author><id>tag:rohitja.in,2015-09-06:hoare-pivot.html</id><summary type="html">&lt;p&gt;Quicksort is a remarkably flexible algorithm with several
variations. Here, I wanted to write about the Hoare partitioning method,
in particular, about the special choice of its pivot as the leftmost
element. First, lets quickly write down the partitioning algorithm from
CLRS &lt;a href="http://clrs.skanev.com/07/problems/01.html"&gt;exercise 7.1&lt;/a&gt;.&lt;/p&gt;
&lt;p _="%" endhighlight="endhighlight"&gt;{% highlight python %}
    def Hoare_Partition(A, p, r):
        x = A[p]
        i = p - 1
        j = r + 1
        while True:
            while True:
                j = j - 1
                if A[j] &amp;lt;= x:
                    break
            while True:
                i = i + 1
                if A[i] &amp;gt;= x:
                    break
            if i &amp;lt; j:
                A[i], A[j] = A[j], A[i]
            else:
                return j      &lt;br /&gt;
    # Output Assertion: A[p..j] &amp;lt;= x and A[j+1..r] &amp;gt;= x
    # in case we use last element to pivot&lt;/p&gt;
&lt;p&gt;This partitioning can be called from quicksort as &lt;/p&gt;
&lt;p _="%" endhighlight="endhighlight"&gt;{% highlight python %}
    def Quick_Sort(A, p, r):
        if p &amp;lt; r:
            q = Hoare_Partition(A, p, r)
            Quick_Sort(A, p, q)
            Quick_Sort(A, q + 1, r)&lt;/p&gt;
&lt;p&gt;Here, I have translated the algorithm into a simple python function. The
only departure from the original algorithm are my implementations of the
repeat-until loops as unconditional while loops that break. The
parameter &lt;code&gt;A&lt;/code&gt; is the array which is 0-indexed, though it does not really
matter here. &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; are the boundaries of the sub-array which we
wish to partition. Now, if one looks at the function definition, the
pivot is used for comparisons of the array elements. However, most of
the code looks to be pretty symmetric, when we compare the left and
right endpoints of the sub-array. Essentially, in the code we are not
"favouring" any particular endpoint, and repeating the same steps for
both of them. The only place where there is some bias, is in the &lt;code&gt;return
j&lt;/code&gt; statement, wherein we return the current value of the right endpoint
index.&lt;/p&gt;
&lt;p&gt;This led me to try using &lt;code&gt;A[r]&lt;/code&gt; as the pivot. However, when I simply
chose this element as the pivot, the algorithm did not terminate and
went into an infinite loop with my test case. Some looking revealed that
this was because the algorithm was not able to reduce the size of the
partitions. Essentially, the array of size n, in the first recursion
itself, was getting "partitioned" into two sub-arrays: &lt;code&gt;[0..n]&lt;/code&gt; and
&lt;code&gt;[n+1..n]&lt;/code&gt;. This is obviously an error, as the second subarray is
meaningless, and the first subarray is the same as the input itself!
Clearly, the partitioning is sensitive to the positioning of the
pivot. This is corroborated by CLRS exercise 7.1 where it is proved that
if &lt;code&gt;r - p &amp;gt;= 2&lt;/code&gt;, then &lt;code&gt;p &amp;lt;= j &amp;lt; r&lt;/code&gt;. The strict inequality between j and
r breaks down if we use the last element as the pivot. In fact, if we
peep into the &lt;a href="http://clrs.skanev.com/07/problems/01.html"&gt;proof&lt;/a&gt; of
this ordering (which, in turn is required to prove the correctness of
the partitioning), it assumes that the first element is the pivot. All
this suggests that the recursive calls made in &lt;code&gt;Quick_Sort&lt;/code&gt; should to be
altered to,&lt;/p&gt;
&lt;p _="%" endhighlight="endhighlight"&gt;{% highlight python %}
    def Quick_Sort_modded(A, p, r):
        if p &amp;lt; r:
            q = Hoare_Partition(A, p, r)
            self.Quick_Sort(A, p, q - 1)
            self.Quick_Sort(A, q, r)&lt;/p&gt;
&lt;p&gt;However, in order to do this, we must depend upon an altered output
assertion of Hoare_Partition that looks like `A[p..i-1] &amp;lt;= x and A[i..r]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;= x`. Symmetry in the function suggests that we should return i instead
of j, and this can be further proved as well by formulating an
invariant. So, the modified Hoare Partitioning should look like&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p _="%" endhighlight="endhighlight"&gt;{% highlight python %}
    def Hoare_Partition_modded(A, p, r):
        x = A[r]
        i = p - 1
        j = r + 1
        while True:
            while True:
                j = j - 1
                if A[j] &amp;lt;= x:
                    break
            while True:
                i = i + 1
                if A[i] &amp;gt;= x:
                    break
            if i &amp;lt; j:
                A[i], A[j] = A[j], A[i]
            else:
                return i
    # Output Assertion: A[p..i-1] &amp;lt;= x and A[i..r] &amp;gt;= x
    # in case we use last element to pivot&lt;/p&gt;
&lt;p&gt;So, this partitioning is pretty rigid in terms of the choice of the
pivot. Hence, if we wish to randomize the pivot selection, we would have
to do that in the &lt;code&gt;Quick_Sort_modded&lt;/code&gt; call itself, by swapping the
chosen pivot with the first/last element of the array.&lt;/p&gt;</summary><category term="algorithms"></category></entry><entry><title>From vim to emacs</title><link href="http://rohitja.in/vim-emacs.html" rel="alternate"></link><published>2013-11-30T19:55:00+05:30</published><author><name>Rohit Jain</name></author><id>tag:rohitja.in,2013-11-30:vim-emacs.html</id><summary type="html">&lt;p&gt;I grew up as a programmer on vim. In my first week at college, I was
treated to an interesting discourse on the virtues of vim, emacs and
their ilk from Prof. Suban which first lead me to appreciate them
better. Vim is simple, and very quickly becomes a part of the
background. You forget that it exists, as you work through the code. Its
loaded with some amazing stuff that can really make you productive, yet
at the same time, it simply does not throw that at you all at once. You
can learn how to use it after following through the first few screens of
vimtutor, and that can be enough for all the editing you will ever
do. Just when you start getting frustrated with doing repetitive stuff
on the screen and start searching around for a smarter way, you will
quickly spot a promising command that will make very short work of the
problem. vim is awesome, and I spent close to six years using it as my
editor of choice.&lt;/p&gt;
&lt;p&gt;A few months ago, reading though some of
&lt;a href="http://steve-yegge.blogspot.in/"&gt;Steve Yegge&lt;/a&gt;'s posts about emacs
convinced me to give emacs a try. This wasn't the first time I had fired
up emacs. I had been through its tutorial a time or two before and could
make my way through it without finding it too alien. However, this time,
I had decided to give it a week. Since then, I have not come back to
using vim. Working with emacs was a period of rediscovery in text
editing. When I was working with vim, my approach to using it was very
functional and lazy. I would only care to learn about something in vim,
when the choice I had was between learning more about my editor or
spending a couple of hours doing things the mundane way. Emacs however,
is nowhere as humble as vim is! Working with the former, I felt that
there was a lot more that I could get done, if I could only learn how to
use feature X properly. And emacs has a quite a few of such feature Xs.&lt;/p&gt;
&lt;p&gt;However despite the apparent promiscuity of emacs, it is a very focused
editor. The coherence of its interface is extremely refreshing. Also, it
makes it very easy to work with complex commands. It infers more about
the text, and its nature when providing its interface, unlike vim, which
does precisely what it is asked to do more often than not. Another
interesting facet of emacs is that it can be used as a complete and
flexible development environment and handle duties as my terminal of
choice, windowing manager, ssh/grep replacement, magit version control,
org mode goodness and a whole lot more.&lt;/p&gt;</summary><category term="tech"></category></entry><entry><title>First Steps</title><link href="http://rohitja.in/first-steps.html" rel="alternate"></link><published>2013-11-30T14:55:00+05:30</published><author><name>Rohit Jain</name></author><id>tag:rohitja.in,2013-11-30:first-steps.html</id><summary type="html">&lt;p&gt;I suppose it was long past time that I started blogging. I love to
write. I also love technology and the ecosystem that surrounds
it. However, despite the presence of both of those two passions, I could
never quite see the charm in creating a blog. A fair bit of that, in
hindsight, had to do with not feeling at home with writing a bunch of
stuff inside a textarea in a browser, however nice. The tools we use to
give effect to our creations are rather important. I prefer writing on
paper, where the smell of the ink, the sounds of the nib hitting the
paper, and the shadings in the colours generate an effect that cannot
easily be communicated. However, now that I begin to write words out on
my vanilla emacs frame, while knowing that I am being much more
efficient a writer and an editor than I ever could manage to be, on my
best day on paper, not to mention the potential of a reader, I think
that it might now, just be worth it.&lt;/p&gt;
&lt;p&gt;Let me start out with a brief description of how this blog exists, and
what ideas and requirements influenced its form. When I decided to start
writing stuff online, I felt that the following were important for me to
do a reasonable job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The editor should be emacs et al.:&lt;/strong&gt; I refused to write inside a
  browser window, with few, if any editing controls at my disposal. If I
  need to write a bunch of stuff, the editor just &lt;em&gt;has&lt;/em&gt; to get out of my
  way. That was not going to happen without a lot of effort inside a
  browser textarea.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The formatting should be minimal:&lt;/strong&gt; I wanted to focus on content,
  and not how it appears. The appearance should be consistent and nice,
  but when creating content, the design really should matter very
  little. Latex makes a lot of sense to me, given that it defines a
  clear focus on describing the document being written, instead of how
  it should appear. Markdown is a lot simpler though for now, not to
  mention faster and more specific.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The content should be under versioning:&lt;/strong&gt; Versioning digital content
  of any kind, makes a lot of sense to me. While I doubt I would be
  doing a lot of branching in the git repo holding this stuff, the diffs
  in the content directory are no doubt going to be helpful, if nothing
  else, then for me to be able to see how my writing has changed over
  the months (if this blog lasts that long).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The idea of a static blog generator, with &lt;a href="https://heroku.com/"&gt;heroku&lt;/a&gt;
that supports deployments on git push seem to fit the bill quite
nicely. The posts are simply markdown pieces of text, with some yaml
metadata on the top that is very easy to make sense of. The entire setup
seems to nicely get out of the way of creating content. The presence of
a database is mostly unnecessary for my requirements. So this is what I
am doing right now. I am using &lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; to
write my posts and am publishing them to heroku. The instructions
&lt;a href="http://def.reyssi.net/blog/2012/01/14/get-blogging-with-octopress-on-heroku/"&gt;here&lt;/a&gt;
by Sam are rather good. The only deviation I needed to make them work
for me was to use ruby v1.9.3 instead of v1.9.2, the latter of which
does not play well with the markdown library octopress uses. I also
tried out &lt;a href="http://zespia.tw/hexo/"&gt;hexo&lt;/a&gt; for a while. However, I felt
that its not very mature right now. Octopress seems to have a much more
active community and that definitely matters a great deal as well. I
felt that Hexo was considerably simpler to deploy, however, and faster
to get started with as well, particularly on heroku. Perhaps I will take
a look at it again someday. Right now, I am too happy to be writing
stuff to be very concerned about it.&lt;/p&gt;</summary><category term="tech general"></category></entry></feed>